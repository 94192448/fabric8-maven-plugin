
[[introduction]]
= Introduction

The *fabric8-maven-plugin* brings your Java applications to http://kubernetes.io/[Kubernetes] and https://www.openshift.com/[OpenShift]. It provides a tight integration into http://maven.apache.org[Maven] builds and benefits from the build information already given. The main tasks where fabric8-maven-plugin can help is in <<building-images,building images>> and creating Kubernetes and OpenShift <<resource-descriptors,resource descriptors>>.

[[building-images]]
== Building Images

The <<fabric8:build>> goal is for creating Docker images which carrythe actual application and which can be deployed on Kubernetes or OpenShift. It is easy to include build artifacts and their dependencies. The plugin uses the assembly descriptor format from the http://maven.apache.org/plugins/maven-assembly-plugin/[maven-assembly-plugin] to specify the content which will be added to a sub-directory in the image (`/deployments` by default). Images that are built with this plugin can then be pushed to public or private Docker registries with <<fabric8:push>>.

Depending on the operational mode, for building the actual image either a Docker daemon is contacted directly or an https://docs.openshift.com/enterprise/3.0/architecture/core_concepts/builds_and_image_streams.html#docker-build[OpenShift Docker Build] is performed.

A special <<fabric8:watch>> goal allows for reacting on code changes and automatic recreation of images or copying new artifacts into running container.

These image related features are inherited from the https://github.com/fabric8io/docker-maven-plugin[fabric8io/docker-maven-plugin] which is transparently included in this plugin.

[[resource-descriptors]]
== Kubernetes and OpenShift Resource Descriptors

With <<fabric8:resource>> Kubernetes and OpenShift resource descriptors can be created from the build information for creating the corresponding resource object. These files are packaged within the Maven artifacts created and can be deployed to a running orchestration platform with <<fabric8:deploy>>.

You only specify a fragment of the real resource descriptors which will be enriched by this plugin with various extra informations taken from the build. This drastically can reduce boilerplate code for common scenarios. It is also possible to auto-create resource objects like services or replica-set without explicitly declaring it.

== Configuration

In order to capture many use case scenarios, there are three levels of configuration:

* *Zero-Config* mode makes some decisions based what is present in the pom.xml like what base image to use or which ports to expose. This is great for starting up things and for keeping quickstart applications small and tidy.

* *XML plugin configuration* mode is similar to what https://fabric8io.github.io/docker-maven-plugin/#example[docker-maven-plugin] provides. This allows for type safe configuration with IDE support, but only a subset of possible resource descriptor festures is provided.

* *Kubernetes &amp; OpenShift resource descruptors* are user provided YAML fragments that can be _enriched_ by the plugin. This allows expert users to use plain configuration file with all their capabilities, but also to add project specific build information and avoid boilerplate code.

== Examples

But let's have a look at some code. The following examples will demonstrate all three configurations variants:

=== Zero-Config

This minimal but full working example `pom.xml` shows how a simple spring boot application can be dockerized and prepared for Kubernetes and OpenShift. The full example can be found in directory https://github.com/fabric8io/fabric8-maven-plugin/tree/master/samples/zero-config[samples/zero-config].

.Example
[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
<project>
  <modelVersion>4.0.0</modelVersion>

  <groupId>io.fabric8</groupId>
  <artifactId>fabric8-maven-sample-zero-config</artifactId>
  <version>{version}</version>
  <packaging>jar</packaging>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId> <!--1-->
    <version>1.3.6.RELEASE</version>
  </parent>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId> <!--2-->
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId> <!--3-->
      </plugin>
      <plugin>
        <groupId>io.fabric8</groupId>
        <artifactId>fabric8-maven-plugin</artifactId> <!--4-->
        <version>{version}</version>
      </plugin>
    </plugins>
  </build>
</project>
----
<1> This minimalistic spring boot application uses the spring-boot parent POM for setting up dependencies and plugins
<2> The Spring Boot web starter dependency enables a simple embedded Tomcat for serving Spring MVC apps
<3> The `spring-boot-maven-plugin` is responsible for repackagign the application into a fat jar, including all dependencies and the embedded Tomcat
<4> The `fabric8-maven-plugin` enables the automatic generation of a Docker image and Kubernetes / OpenShift descriptors including this Spring application.

This setup make some opinionated decisions for you:

* As base image https://github.com/fabric8io-images/java/tree/master/images/alpine/openjdk8/jdk[fabric8/java-alpine-openjdk8-jdk] is chosen which enables https://www.jolokia.org[Jolokia] and https://github.com/prometheus/jmx_exporter[jmx_exporter]. It also comes with a sophisticated https://github.com/fabric8io-images/run-java-sh[startup script].
* It will create a Kubernetes http://kubernetes.io/docs/user-guide/deployments/[Deployment] and a http://kubernetes.io/docs/user-guide/services/[Service] as resource objects
* It exports port 8080 as the apllication service port (and 8778 and 9779 for Jolokia and jmx_exporter access, respectively)

These choices can be influenced by configuration options as decribed in <<generator-spring-boot,Spring Boot Generator>>.

To start the Docker image build, you simply run

[source,bash]
----
mvn package fabric8:build
----

This will create the Docker image against a running Docker daemon (which must be accessible either via Unix Socker or with the URL set in `DOCKER_HOST`). Alternatively, when using `mvn -Dfabric8.mode=openshift package fabric8:build` and connected to an OpenShift cluster, then a Docker build will be performed on OpenShift which at the end creates an https://docs.openshift.com/enterprise/3.1/architecture/core_concepts/builds_and_image_streams.html[ImageStream].

To deploy the resources to the cluster call

[source,bash]
----
mvn fabric8:resource fabric8:deploy
----

By default a _Service_ and a _Deployment_ object pointing to the created Docker image is created. When running in OpenShift mode, a _Service_ and _DeploymentConfig_ which refers the _ImageStream_ created with `fabric8:build` will be installed.

Of course you can bind all those fabric8-goals to execution phases as well, so that they are called along with standard lifecycle goals like `install`:

.Example for lifecycle bindings
[source, xml, indent=0]
----
<plugin>
  <groupId>io.fabric8</groupId>
  <artifactId>fabric8-maven-plugin</artifactId>

  <!-- ... -->

  <executions>
    <execution>
      <goals>
        <goal>resource</goal>
        <goal>build</goal>
        <goal>deploy</goal>
      </goals>
    </execution>
  </executions>
</plugin>
----

=== XML Configuration

WARNING: XML based configuration is implemented only partially and not recommended to use right now.

Altough the Zero-config mode with its generators can be tweaked with options up to a certain degree. In many cases more flexibility and power is required, though. For this an XML based plugin configuration can be use, much similar to the https://fabric8io.github.io/docker-maven-plugin/#configuration[XML configuration] used by `docker-maven-plugin`.

The plugin configuration can be roughly divided into the following sections:

* A global configuration options are responsible for tuning the behaviour of plugin goals
* ``<images>`` section which defines the Docker <<image-configuratuon,images>> to build. It has the https://fabric8io.github.io/docker-maven-plugin/#image-configuration[same syntax] as the similar configuration of `docker-maven-plugin` (except that `<run>` and `<external>` sub-elements are ignored)
* `<resource>` is used to defined the resource descriptors for deploying on an OpenShift or Kuberneres cluster.
* `<generator>` is for configuring <<generator,generators>> which are responsible for creating images. Generators are used as an alternative to a dedicates `<images>` section.
* `<enricher>` is used to configure various aspects of <<enricher,enrichers>> for creating or enhancing resource descriptors.

A working example can be found in the  https://github.com/fabric8io/fabric8-maven-plugin/tree/master/samples/xml-config[samples/xml-config] directory. An extract of the plugin configuration is shown in the next example

.Example for an XML configuration

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
<configuration>
  <images>  <!--1-->
    <image>
      <name>xml-config-demo:1.0.0</name>
      <!-- "alias" is used to correlate to the containers in the pod spec -->
      <alias>camel-app</alias>
      <build>
        <from>fabric8/java</from>
        <assembly>
          <basedir>/deployments</basedir>
          <descriptorRef>artifact-with-dependencies</descriptorRef>
        </assembly>
        <env>
          <JAVA_LIB_DIR>/deployments</JAVA_LIB_DIR>
          <JAVA_MAIN_CLASS>org.apache.camel.cdi.Main</JAVA_MAIN_CLASS>
        </env>
      </build>
    </image>
  </images>

  <resources> <!--2-->
    <labels> <!--3-->
      <group>quickstarts</group>
    </labels>

    <deployment> <!--4-->
      <name>${project.artifactId}</name>
      <replicas>1</replicas>

      <containers> <!--5-->
        <container>
          <alias>camel-app</alias> <!--6-->
          <ports>
            <port>8778</port>
          </ports>
          <mounts>
            <scratch>/var/scratch</scratch>
          </mounts>
        </container>
      </containers>

      <volumes> <!--7-->
        <volume>
          <name>scratch</name>
          <type>emptyDir</type>
        </volume>
      </volumes>
    </deployment>

    <services> <!--8-->
      <service>
        <name>camel-service</name>
        <headless>true</headless>
      </service>
    </services>
  </resources>
</configuration>
----
<1> Standard docker-maven-plugin configuration for building one single Docker image
<2> Kubernetes / OpenShift resources to create
<3> Labels which should be applied globally to all resource objects
<4> Definition of a http://kubernetes.io/docs/user-guide/deployments/[Deployment] to create
<5> Container to include in the deployment
<6> An _alias_ is used to correlate a container's image with the image definition in the `<images>` section where each image carry an alias. Can be omitted if only a single image is used
<7> http://kubernetes.io/docs/user-guide/volumes/[Volume] definitions used in a Deployment's _ReplicaSet_
<8> One or more http://kubernetes.io/docs/user-guide/services/[Service] definitions.

The XML resource configuration is based on plain Kubernetes resource objects. For creating OpenShift resource descriptor an automatic conversion will happen, e.g. from Kubernetes http://kubernetes.io/docs/user-guide/deployments/[Deployment] to an OpenShift https://docs.openshift.com/enterprise/3.0/dev_guide/deployments.html[DeploymentConfig].

=== Enhanced YAML Descriptors
